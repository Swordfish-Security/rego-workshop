Теория
=================
* [Перед погружением в синтаксис](#перед-погружением-в-синтаксис)
    * [Rego v1 vs Rego v0](#rego-v1-vs-rego-v0)
    * [Разница между правилом и политикой](#разница-между-правилом-и-политикой)
* [Основы синтаксиса](#основы-синтаксиса)
    * [Как обратиться к элементу составного типа?](#как-обратиться-к-элементу-составного-типа)
    * [Специальные слова](#специальные-слова)
    * [Булевы операции](#булевы-операции)
    * [Array/set/object comprehensions](#arraysetobject-comprehensions)

## Перед погружением в синтаксис

### Rego v1 vs Rego v0

Rego существует уже не первый год и в конце 2024 - начале 2025 вышла версия OPA 1.0, которая, помимо всего прочего, принесла обновление в синтаксис Rego. Новая версия Rego призвана сделать синтаксис более читаемым для человека и добавить более строгие проверки кода.

Большинство обучающих материалов (в том числе официальные от Styra) на момент написания доклада рассказывают именно про синтаксис v0. Мы не рекомендуем учить синтаксис v0, так как он является устаревшим и не рекомендуется к использованию создателями Rego. Старые материалы можно использовать для ознакомления с общими принципами и концептами Rego, но тогда следует параллельно обращаться к синтаксису v1 для актуализации информации.

Мы в своём воркшопе будем показывать все примеры используя синтаксис v1.

Ниже пример одного из правил KICS (правило для Dockerfile, в котором указана версия образа `latest`) на старой и новой версии.

Rego v0:

```rego
package Cx

CxPolicy[result] {
	resource := input.document[i].command[name][_]
	resource.Cmd == "from"
	not resource.Value[0] == "scratch"
	contains(resource.Value[0], ":latest")

	result := {
		"documentId": input.document[i].id,
		"searchKey": sprintf("FROM={{%s}}", [name]),
		"issueType": "IncorrectValue", # "MissingAttribute" / "RedundantAttribute"
		"keyExpectedValue": sprintf("FROM %s:'version' where version should not be 'latest'", [resource.Value[0]]),
		"keyActualValue": sprintf("FROM %s'", [resource.Value[0]]),
	}
}
```

Rego v1:

```rego
package cx

policy contains result if {
	some i in input.document
	some name, item in i.command
	some resource in item
	resource.Cmd == "from"
	not resource.Value[0] == "scratch"
	contains(resource.Value[0], ":latest")

	result := {
		"documentId": i.id,
		"searchKey": sprintf("FROM={{%s}}", [name]),
		"issueType": "IncorrectValue", # "MissingAttribute" / "RedundantAttribute"
		"keyExpectedValue": sprintf("FROM %s:'version' where version should not be 'latest'", [resource.Value[0]]),
		"keyActualValue": sprintf("FROM %s'", [resource.Value[0]]),
	}
}
```

Политика переписана на v1 без изменения логики оригинала. Исправлены только предупреждения regal о плохом качестве кода.

И хотя первый пример может казаться более коротким, второй является более читаемым. Во время написания политик Styra призывает заботиться больше об их читаемости, чем о производительности. Оптимизируйте производительность только в том случае, если вам это действительно необходимо.

### Разница между правилом и политикой

Правилом считается любое выражение на Rego. Это - правило:

```rego
master_role := "admin"
```

Политика - это совокупность правил, которые объединены общей целью или назначением и используются для проверки входящих ресурсов. Т.е. 1 политика состоит из множества правил. Это - политика:

```rego
package policy

is_moderator if {
	master_role := "admin"
	input.role == master_role
}

is_moderator if {
	input.reputation >= 100
}

is_customer if {
	not is_moderator
	slave_role := "customer"
	input.role == slave_role
}
```

## Основы синтаксиса

Для именования переменных используется snake_case. Присваивание переменной (правилу) значения происходит с помощью `:=`:

```rego
human_temperature := 36.6
```

В Rego все переменные являются константами. То есть изменить существующие переменные невозможно. Чтобы как-то изменить значение переменной или взять только определённые значения из массива, необходимо создавать новую переменную.

Обращения к полям JSON, составных типов, вызовы функций происходят со помощью `.`:

```rego
input.message == "hello"
```

В Rego есть 2 типа переменных: скалярные (scalar) и составные (composite).

Скалярные типы включают в себя:

* строки
* числа
* булевы значения (true/false)
* null

Составные типы включают в себя:

* массивы (array)
* объекты (objects)
* множества (set)

**Массивы (array):**

Массивы - это упорядоченные коллекции значений. Массивы в Rego имеют нулевую индексацию и могут содержать любые значения, включая другие переменные.

```rego
array := [1, container, "string", 1]
```

**Объекты (objects):**

Объекты - это неупорядоченные коллекции ключей-значений. В Rego любой тип значения может быть использован в качестве ключа объекта. При конвертации в JSON все ключи будут преобразованы в строки (таков JSON).

```rego
object := {"a": 1, "b": container, "c": "string", 11: 1}
```

**Множества (set):**

Множества - это неупорядоченные коллекции уникальных значений. Как и другие составные типы, множества могут содержать любые значения. Важное различие между множествами и массивами или объектами заключается в том, что множества не индексированы, т. е. нельзя ссылаться на индекс элемента в множестве.

```rego
set := {1, container, "string"}
```

Если попробовать добавить неуникальные значения, то Rego их просто удалит при исполнении политики.

Rego рекомендует использовать именно сеты вместо массивов, потому что:

* Сеты гарантируют уникальность и неупорядоченность элементов
* Производительность: сложность перебора сета - O(1), а перебора массива - O(n)
* [Операций над сетами](https://www.openpolicyagent.org/docs/latest/policy-reference/#sets-2) немного больше

|    | **Массивы (array)** | **Объекты (objects)** | **Множества (set)** |
|----|----|----|----|
| Тип | Значение | Ключ-значение | Значение |
| Индекс | ✅ | ✅ | ❌ |
| Упорядочены | ✅ | ❌ | ❌ |
| Уникальность значений | ❌ | ❌ | ✅ |
| Скобки | \[ \] | { } | { } |

### Как обратиться к элементу составного типа?

Обращаться можно либо с помощью точек, либо с помощью `[ ]`, куда можно указать строки, числа, переменные или `_` (можно также использовать булевы значения и null, но практического смысла в этом нет). Что это значит?

Предположим, что у нас есть JSON следующего вида:

```json
{
  "aquarium": {
    "name": "Coral Haven",
    "fish": [
      {
        "name": "Bubbles",
        "species": "Clownfish",
        "color": "Orange",
        "amount": 2,
        "is_salty": true,
        "favorite_foods": ["Plankton", "Algae", "Small Shrimp"]
      },
      {
        "name": "Slicer",
        "species": "Swordfish",
        "color": "Silver",
        "amount": 1,
        "is_salty": true,
        "favorite_foods": ["Squid", "Mackerel", "Herring"]
      },
      {
        "name": "Sneaky",
        "species": "Eel",
        "color": "Green",
        "amount": 0,
        "is_salty": true,
        "favorite_foods": ["Crabs", "Worms", "Fish Chunks", "Small Shrimp"]
      }
    ],
    "water_type": "Mixed",
    "max_fish": 5
  }
}
```

И нам нужно вытащить элемент `"Algae"` из `favorite_foods` у первой рыбы. Сделать это можно 2 способами:

```rego
# Вариант 1
fish1 := input.aquarium.fish[0].favorite_foods[1]
    
# Вариант 2
fish2 := input["aquarium"]["fish"][0]["favorite_foods"][1]
```

Оба способа вернут  `"Algae"`, однако первый вариант является более предпочтительным, потому что более читаемый.

Но что если нужно проитерироваться по элементам массива и получить, например, список еды у всех рыб? Для этого можно использовать переменные:

```rego
output contains food if {
	some i
	some j
	food := input.aquarium.fish[i].favorite_foods[j]
}


# Технически присваивание food необязательно, и можно после contains сразу написать
# input.aquarium.fish[i].favorite_foods[j]. Но в таком случае будет нарушено правило Regal
# use-some-for-output-vars
output2 contains input.aquarium.fish[i].favorite_foods[j] if {
	some i
	some j
}
```

Здесь мы сначала объявляем переменные `i` и `j`, а потом используем их для итерации по всем массивам `favorite_foods`.

Однако более правильным с точки зрения синтаксиса Rego было бы использование следующей конструкции. Её вывод ничем не отличается от двух предыдущих, но эта версия полностью соответствует синтаксису новой версии.

```rego
output contains food if {
	some fish in input.aquarium.fish
	some food in fish.favorite_foods
}
```

Если не важно, к каким переменным мы обращаемся (не проверяем, что они (не)соответствуют чему-то или не используются в других переменных), то можно использовать анонимные переменные `_`. Они обычно используются, когда надо вытащить все значения из массива вне зависимости от их содержимого.

```rego
output contains input.aquarium.fish[_].favorite_foods[_]
```

### Специальные слова

Следующие слова зарезервированы и не могут использоваться в качестве имен переменных, имен правил или обращений к составным типам в стиле dot-access:

```rego
as
contains
data
default
else
every
false
if
in
import
input
package
not
null
some
true
with
```

Некоторые из них зарезервированы потому что являются значениями переменных (`null`, `false`, `true`). А некоторые являются частью future words. Это специальные слова, которые представляют собой новый синтаксис Rego. Мы уже говорили, что на данном воркшопе рассматриваем синтаксис Rego v1. По сути все эти слова являются более читаемой заменой каких-то специальных выражений на Rego. Какие-то из них уже были представлены ранее, и сейчас мы их разберём подробнее.

**if:**

Раньше оно было не нужным и его не существовало в принципе. А в Rego v1 оно стало обязательным к использованию перед каждым условием. Оно представляет собой начало для какого-либо условия, при котором правило принимает значение. Если правило, для которого применяется это условие должно принять значение `true`, то его можно не писать: Rego подставит это значение по умолчанию. Также если правило содержит всего 1 условие, то фигурные скобки указывать не обязательно.

Переменные внутри `if` локальные и видны только в рамках этого блока `if`.

```rego
allow if input.aquarium.name == "Coral Haven"
```

**input:**

Слово, которое используется для обращению к пришедшему JSON. OPA маппит этот JSON на внутреннюю переменную `input`.

```rego
allow if input.aquarium.name == "Coral Haven"
```

**contains:**

Данное слово необходимо на случай, если правило на основе условия может выводить больше 1 значения. Это может быть полезно, например, если нам нужно проитерироваться по элементам JSON и проверить, что каждый из элементов соответствует какому-то условию. Мы его использовали когда нам нужно было получить список еды у всех рыб.

В результате выполнения правила выводится сет (и именно он, несмотря на то, что в выводе Rego Playground выводятся квадратные, а не фигурные скобки. Проверить это можно с помощью встроенной функции `type_name`. Например: `type := type_name(output)`).

```rego
output contains food if {
	some fish in input.aquarium.fish
	some food in fish.favorite_foods
}
```

**some:**

Some позволяет явно объявить локальную переменную, но не присваивать ей значение. Также с помощью some можно обратиться к элементу массива или сета, а также к ключу и значению объекта. 

```rego
output contains food if {
	some i
	some j
	food := input.aquarium.fish[i].favorite_foods[j]
}
```

**some … in… :**

А с помощью конструкции some … in … можно обратиться к элементу и индексу массива, элементу сета, а также к ключу и значению объекта. 

```rego
output contains id_food if {
	some index, fish in input.aquarium.fish
	some food in fish.favorite_foods
    id_food := {index: food}
}
```

### Булевы операции

Про присвоение поговорили, про обращение к элементам сложных типов тоже. Даже обсудили использование нового синтаксиса Rego. А как проверять какие-то элементы на соответствие и логически объединять правила?

В Rego есть операторы сравнения:

```rego
x := 3
y := 2

allow if x > y
allow2 if x >= y
allow3 if x == y

# Вместо такой записи лучше использовать allow4 if not x == y
allow4 if x != y
```

Есть также и булевы операторы, с помощью которых можно логически объединять правила:

**НЕ:**

В Rego логическое НЕ представлено с помощью слова `not`. Ставится оно всегда в начале правила и не может стоять перед правилами, которые имеют if.

```rego
# Так можно
allow if not input.aquarium.name == "Coral Haven"

# Так нельзя
not allow if input.aquarium.name == "Coral Haven"
```

**И:**

В Rego логическое И является набором условий (по сути это тоже правила, но для удобства назовём их условиями), заключенным в блок `if`. Условия проверяются последовательно сверху вниз. Если одно условие проваливает проверку, правило дальше не проверяется.

```rego
output contains fish if {
	some fish in input.aquarium.fish
	fish.is_salty == true
    fish.amount == 2
}
```

**ИЛИ:**

В Rego логическое ИЛИ является набором правил, имеющих блок `if`, с одинаковым названием. Такие правила должны иметь одинаковый тип на выходе. Так как в Rego массивы и сеты могут содержать значения разных типов, то мы можем одним из элементов массива сделать число (хотя до этого были объекты). Но вот присвоить вместо элемента массива само число уже нельзя. Rego будет говорить о том, что правила конфликтуют между собой.

```rego
output contains fish if {
	some fish in input.aquarium.fish
	fish.is_salty == true
	fish.amount == 2
}

output contains fish if {
	some fish in input.aquarium.fish
	fish.species == "Swordfish"
}


# Так можно
output contains 1 if true

# Так нельзя
output := 1 if true
```

### Array/set/object comprehensions

Rego позволяет с помощью comprehensions создавать массивы, сеты и объекты, используя дополнительные запросы к входящим данных. Вот так строится любой comprehension в Rego:

```rego
переменная_массива := [элемент_массива |
  условие 1
  условие 2
  ...
]
```

Зачем это нужно? Так как в Rego все переменные являются константами, то невозможно просто так написать, например, правило, которое просуммирует общее количество всех рыб в аквариуме. Есть вариант написать отдельное правило: там проитерироваться по каждому элементу и на выходе записать всё это в отдельный массив. Далее этот массив можно использовать уже в другом правиле. Но что если нам нужно сохранить какую-то ещё информацию, помимо числа, чтобы сравнить с текущим объектом `some`? Можно записать объект и обрабатывать уже его. Но это гораздо сложнее.

А можно никакое отдельное правило не писать и использовать comprehensions. Вот так можно вывести сумму рыб в нашем аквариуме:

```rego
output := fish_sum if {
	fish_amount := [fish.amount |
		some fish in input.aquarium.fish
	]

	fish_sum := sum(fish_amount)
}
```

**На этом моменте уже можно переходить к практике! Она находится в соседней папке `practice`**